mgr.py has testing code i was using...

to use:
import antisurveillance

-------------------------

buildhttp4 arguments:
example:
        a.buildhttp4(src_ip, src_port, dst_ip, dst_port, client_body, server_body)

It will also accept keywords.  IE: a.buildhttp4(client_ip:src_ip,.....)

client_ip: (source_ip)
client_port: (1024+rand()%(65535-1024))
destination_ip: (web server)
destination_port: 80
client_body: string of body
server_body: response from www server

These are not required:

count: how many times to repeat this session? 99999 is default
interval: how many seconds in between repeating it? 1 default
client_ttl: client side ttl (OS emulation... ) default 64
server_ttl: server side ttl (OS emulation) my VPS was 53.. linux digitalocean
client_window_size: (1500 - sizeof(udphdr)(20) + sizeof(iphdr)(20) + sizeof(tcp options)(12))
server_window_size:  (1500 - sizeof(udphdr)(20) + sizeof(iphdr)(20) + sizeof(tcp options)(12))
client_identifier: initial ip header identifier (increases by 1 usually every packet)
server_identifier: initial ip header identifier (increases by 1 usually every packet)
client_os: not implemented os emulation fully yet
server_os: not implemented os emulatioon fully yet

-------------------------

attackperform()
example:

def perform(a):
        count = 0
        while (count < 30): #or 10
                print("AS_perform() - Count is %d") % count
                a.attackperform()
                count = count + 1

iterates one loop of all attack structures..after building http psession above it has 10 packets so this would need to be called 10 times
to get the first full session into the wire queue... 
-------------------------

pcapsave("filename")

no keywords for this one...

save all current network queue packets to a pcap filename

This can allow you to replay the pcap elsewhere without the software, or just check it out in wireshark. Once
raw packet capture is enabled w filters itll have more uses.
-------------------------

networkcount()

count all packets in the outgoing network queue (amount to be dumped to disk using pcapsave)


-------------------------

attackclear() 

clear out all attack structures currently in the system

-------------------------

networkon()

enable output to network

can turn this off to save them up for a pcap dumped
-------------------------

networkoff()

disable otuuput to networkk

for queueing packets before dumpping to pcap

-------------------------

networkclear()

clear all outgoing queues

-------------------------

pcapload("filename")
    static char *kwd_list[] = { "filename", "use_python_filter", "destination_port", 0 };

    filename is needed...
    use_python_filter is for if you use python to prepare a filter...
    destination_port isnt required if your ok with the default of www (80)

load all http sessions from a pcap file as different attack structures

-------------------------

clear()

clear all attacks, and outgoing packets queued gracefully (their own cleanup
routines will handle them)

-------------------------

disable()

disable everything in AS_perform()... the loop just returns

-------------------------

enable()

re-enables AS_perform

-------------------------

exit()

exit software immediately

-------------------------

setctx(ctx_pointer)

used to set a context poointer from C to python...
this is my 2nd or 3rd time ever trying to use python embedded... I have to
handle this a different way.. 

this has to be in the python file:
def init():
        # this should be removed and done completely in C.. i need to see how the object is allocated and hook it or somethiing..
        # would rather work on other stuff first ***
        a = antisurveillance.manager()
        a.setctx(ctx)


-------------------------

filtercreate()

zero's the filter (starts it fresh waiting for *prepare())

create a filter used for things like pcapload

-------------------------

filterprepare()
accepts keywords

prepare the filter using various parameters that you may wish to search for in the pcap

arguments:
    static char *kwd_list[] = { "source_ip", "destination_ip", "source_port", "destination_port",
    "packet_flags", "familiar", 0};

    whichever arguments you provide will be used.. you can call it several times with different arguments
    only filtercreate() will clean it up

    familiar should be used for TCP (it will match both sides of the connection.. for instance going to
    server, and coming fromm server)

    TCP flags... ill have to put them here later.. sync in 18 hours



-------------------------

instructionscreate()

accepts keywords

argments are almost the same as buildhttp4.. but it allow using the instructions commands below to
build whatever tcp/ip protocol you'd like (not http)

"client_ip", "client_port", "destination_ip", "destination_port", "client_ttl", "server_ttl", 
    "client_window_size", "server_window_size",
    
    these arent necessary but possible...

    "client_seq", "server_seq", "client_identifier",
    "server_identifier", "client_os","server_os"


start a new instructions list (immediately discarding anything that wasnt saved as a built attack)

-------------------------

instructionstcp4open()

add to current instructions list (after create) the source ip opening the connection to the destinatioon
(produces all packets for the 3way tcp handshake)

-------------------------

instructionstcp4send()
accepts keywords
arguments: "from_client" 1 or 0 (is the connecting party sending the data, or the server)
"data" - data... (itll get the size automatically)

send data from one side of the tcp connection to the other, the side is chosen by
"from_client" parameter

-------------------------

instructionstcp4close()

accepts keywords

arguments: "from_client" which side is closing the connection
close the tcp connectioon from one side or the other.. the side is chosen by "from_client"


-------------------------

instructionsbuildattack()
accepts keywords - arguments: 
count - (how many times to repeat this attack)
default:999

interval - how many seconds in between the repeats
default:1

turns all current instructions which were made using other functions into an attack, and enables it

-------------------------

blackholeclear()

clear all blackhole ips/targets
-------------------------

blackholeadd()

add to blackhole list

-------------------------

blackholedisable()

disable blackhole attacks

-------------------------

blackholeenable()

enable blackhole attacks

-------------------------

