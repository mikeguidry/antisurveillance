python
site id
traffic id (pcap ID? live capture ID)
size
ts created, last used



create server body (for http fabrication)
create client body (same)

get identity
replace identity

generate messages

blackhole get list
blackhole set list
blackhole attack start/stop (timers, etc, campaign ids 1 ip list = 1 campaign, another = a diff) since some will have different
timers required to continously keep all traffic offline


----
manage:
turn on/off ID (attack structure)
load file
save to file (ability to generate, ,and do other thingss in a new context, and then save instead of dumping to network) .. or save fromm live captures


all scripting/python needs ability to control the system, and also be used on callbacks for certain things... 

all aspects of the software should be configurable from the scripting languages
a multi dimensional array, or objects which can be set and then updated might be the easiest (to ensure all changes hapapen accurately, immediately)
rather than the script applying some change, and it not getting others for a few cycles

turn on/off live capturing

picking filters for turning pcap loading, or capturing to attaack structures

linking multiple attqack kstructures together (for insntance, DNS/WWW) (the script can analyze itself and decide)

pcap save/load

generation of instructions (python app can build packets directly by setting source ip, dest ip, ports) and start buildinng by giving data...
so all fabrication can happen inn python and then it will get loaded into the C portion to get repllayed, and repicated (extremely fast)

content modification for attack structures should have a callback into python so that it can do its own packet adjustmentss (skippinng, or not
the C++ ones which change ack/seq, etc).. all portions of all packets shouild be reachable fromm python

pausing/unpausing attqack structures (for instance if we are odifyinng it)
locking an attackk structures mutex, or unlocking (not necessarily pausing but stoppinng other things fromm reaching that AS)

setting, getting IP lists (ranges used when deciding IP choices for a web server, or client side)

activating traceroute comparison, etc and gettinng the resulting IPs strategy back.. as an array (which can then get loaded using set IP list)

seting gzip attack parameters

os emulation settings..
innserting new operatinng systems, clearing/disabling compiled in ones, ,settinng percentages...
choosinng different OS picks for different regions (countries) 

http header operatinng systems (manipulation of user agents, paired with OS emulation) settinng user agents
removing, clearing list, etc

creating new context to separate sessions completey (one can load a pcap while the other is attacking)
bridging context together like earlier can be done using DNS/WWW into a single sessions

creating raw packets in python

getting callbacks for raw filters on read promisc socket

configuration loading (context save load state) with saving to file, or to python variables

cryptography (rc4/5/whatever) in C but extended to python (with ability to return all information using it
so it can get branched off to a remote host, where python doesnt know the keys)


afsdwefwezfdsZfdszfsdzeewttewwt3werqtth4th


python needs to call functionss during a call back

c -> python (for callbacks)
w loops done in C

or..

python -> C (loops done in python.. python will decide when to call performs())


C with calls to python is best for live mode (capture sessioons and repllay automatically w new IPs)


/*

without gettinng too crazy into scripting immediately.. it shoould be posssibe to crfeate attacks with different bodies...
we can allow python to change the client, and server body... and they can just modify the body and create an attack...
that attack will continue to use that body, aand then it can modify it, and create anothere

this will allow the system to immediately be used by people once the IP strategies are controlled... (random works now)

for advanced procedures:
we can monitor irc, or some other information (logic) and then dynamically generate responses as pyython commands.. and eval it
this will allow easily taking the minimal C versioon and expanding it directly with python to build an entire framework  immediately

---
fromm sommething about eval/exec:

The short answer, or TL;DR

Basically, eval is used to evaluate a single dynamically generated Python expression, and exec is used to execute dynamically generated Python code only for its side effects.

eval and exec have these two differences:

eval accepts only a single expression, exec can take a code block that has Python statements: loops, try: except:, class and function/method definitions and so on.

An expression in Python is whatever you can have as the value in a variable assignment:
a_variable = (anything you can put within these parentheses is an expression)
eval returns the value of the given expression, whereas exec ignores the return value from its code, and always returns None (in Python 2 it is a statement and cannot be used as an expression, so it really does not return anything).

!! exec is way to go
---



*/

